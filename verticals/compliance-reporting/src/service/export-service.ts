/**
 * Compliance Report Export Service
 *
 * Handles export of compliance reports to PDF, CSV, XML formats
 */

import type { Pool } from 'pg';
import type { ExportFormat, ComplianceReportTemplate, GeneratedFileInfo } from '@care-commons/core/types/compliance-reporting.js';
import * as ExcelJS from 'exceljs';
import * as PDFDocument from 'pdfkit';
import { XMLBuilder } from 'fast-xml-parser';
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as path from 'path';

export class ExportService {
  private readonly EXPORT_DIR = process.env.COMPLIANCE_EXPORT_DIR || '/tmp/compliance-exports';

  constructor(private db: Pool) {
    this.ensureExportDirectory();
  }

  /**
   * Ensure export directory exists
   */
  private async ensureExportDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.EXPORT_DIR, { recursive: true });
    } catch (error) {
      console.error('Failed to create export directory:', error);
    }
  }

  /**
   * Export report to specified format
   */
  async exportReport(
    reportId: string,
    format: ExportFormat,
    records: any[],
    template: ComplianceReportTemplate
  ): Promise<GeneratedFileInfo> {
    let buffer: Buffer;
    let mimeType: string;
    let extension: string;

    switch (format) {
      case 'PDF':
        buffer = await this.exportToPDF(records, template);
        mimeType = 'application/pdf';
        extension = 'pdf';
        break;
      case 'CSV':
        buffer = Buffer.from(await this.exportToCSV(records, template), 'utf-8');
        mimeType = 'text/csv';
        extension = 'csv';
        break;
      case 'XLSX':
        buffer = await this.exportToExcel(records, template);
        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        extension = 'xlsx';
        break;
      case 'XML':
        buffer = Buffer.from(await this.exportToXML(records, template), 'utf-8');
        mimeType = 'application/xml';
        extension = 'xml';
        break;
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }

    // Generate filename and hash
    const filename = this.generateFilename(template, format);
    const hash = crypto.createHash('sha256').update(buffer).digest('hex');
    const filepath = path.join(this.EXPORT_DIR, reportId, filename);

    // Ensure report directory exists
    await fs.mkdir(path.dirname(filepath), { recursive: true });

    // Write file
    await fs.writeFile(filepath, buffer);

    const fileInfo: GeneratedFileInfo = {
      format,
      filename,
      path: filepath,
      sizeBytes: buffer.length,
      hash,
      generatedAt: new Date(),
      mimeType
    };

    // Update database
    await this.updateReportFiles(reportId, format, fileInfo);

    return fileInfo;
  }

  /**
   * Export to PDF using PDFKit
   */
  private async exportToPDF(records: any[], template: ComplianceReportTemplate): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50, size: 'LETTER' });
      const buffers: Buffer[] = [];

      doc.on('data', (chunk) => buffers.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(buffers)));
      doc.on('error', reject);

      // Header
      doc.fontSize(16).text(template.templateName, { align: 'center' });
      doc.fontSize(10).text(`State: ${template.stateCode}`, { align: 'center' });
      doc.fontSize(10).text(`Regulatory Agency: ${template.regulatoryAgency}`, { align: 'center' });
      doc.moveDown();

      // Metadata
      doc.fontSize(12).text('Report Information', { underline: true });
      doc.fontSize(10).text(`Generated: ${new Date().toLocaleString()}`);
      doc.fontSize(10).text(`Total Records: ${records.length}`);
      doc.moveDown();

      // Data table (simplified)
      if (records.length > 0) {
        doc.fontSize(12).text('Report Data', { underline: true });
        doc.fontSize(8);

        const headers = Object.keys(records[0]);
        const maxRecords = Math.min(records.length, 50); // Limit for PDF

        for (let i = 0; i < maxRecords; i++) {
          const record = records[i];
          doc.text(`Record ${i + 1}:`);
          headers.forEach(key => {
            doc.text(`  ${key}: ${record[key]}`);
          });
          doc.moveDown(0.5);

          // Add new page if needed
          if (doc.y > 700) {
            doc.addPage();
          }
        }

        if (records.length > maxRecords) {
          doc.text(`... and ${records.length - maxRecords} more records`);
        }
      }

      // Footer
      doc.fontSize(8).text(
        `Generated by Care Commons Compliance Reporting System - ${new Date().toISOString()}`,
        50,
        doc.page.height - 50,
        { align: 'center' }
      );

      doc.end();
    });
  }

  /**
   * Export to CSV
   */
  private async exportToCSV(records: any[], template: ComplianceReportTemplate): Promise<string> {
    if (records.length === 0) {
      return '';
    }

    const headers = template.requiredFields.length > 0
      ? template.requiredFields
      : Object.keys(records[0]);

    const rows: string[] = [];

    // Add header row
    rows.push(headers.map(h => `"${h}"`).join(','));

    // Add data rows
    for (const record of records) {
      const values = headers.map(header => {
        const value = record[header];
        if (value === null || value === undefined) {
          return '""';
        }
        if (typeof value === 'string') {
          return `"${value.replace(/"/g, '""')}"`;
        }
        if (value instanceof Date) {
          return `"${value.toISOString()}"`;
        }
        return `"${String(value)}"`;
      });
      rows.push(values.join(','));
    }

    return rows.join('\n');
  }

  /**
   * Export to Excel using ExcelJS
   */
  private async exportToExcel(records: any[], template: ComplianceReportTemplate): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet(template.reportType);

    // Add metadata
    worksheet.addRow(['Report Name', template.templateName]);
    worksheet.addRow(['State', template.stateCode]);
    worksheet.addRow(['Regulatory Agency', template.regulatoryAgency]);
    worksheet.addRow(['Generated', new Date().toLocaleString()]);
    worksheet.addRow(['Total Records', records.length]);
    worksheet.addRow([]); // Empty row

    if (records.length > 0) {
      const headers = template.requiredFields.length > 0
        ? template.requiredFields
        : Object.keys(records[0]);

      // Add header row
      const headerRow = worksheet.addRow(headers);
      headerRow.font = { bold: true };
      headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFD3D3D3' }
      };

      // Add data rows
      for (const record of records) {
        const values = headers.map(header => {
          const value = record[header];
          if (value instanceof Date) {
            return value.toISOString();
          }
          return value;
        });
        worksheet.addRow(values);
      }

      // Auto-fit columns
      worksheet.columns.forEach(column => {
        if (column?.values) {
          const lengths = column.values.map(v => String(v).length);
          const maxLength = Math.max(...lengths.filter(v => typeof v === 'number'));
          column.width = Math.min(maxLength + 2, 50);
        }
      });
    }

    return workbook.xlsx.writeBuffer() as Promise<Buffer>;
  }

  /**
   * Export to XML
   */
  private async exportToXML(records: any[], template: ComplianceReportTemplate): Promise<string> {
    const builder = new XMLBuilder({
      ignoreAttributes: false,
      format: true,
      attributeNamePrefix: '@_',
      textNodeName: '#text'
    });

    const xmlData = {
      ComplianceReport: {
        '@_xmlns': 'urn:care-commons:compliance-reporting',
        '@_version': '1.0',
        Metadata: {
          TemplateName: template.templateName,
          TemplateCode: template.templateCode,
          StateCode: template.stateCode,
          ReportType: template.reportType,
          RegulatoryAgency: template.regulatoryAgency,
          GeneratedAt: new Date().toISOString(),
          RecordCount: records.length
        },
        Records: {
          Record: records.map((record, index) => ({
            '@_id': index + 1,
            ...record
          }))
        }
      }
    };

    return builder.build(xmlData);
  }

  /**
   * Generate filename for export
   */
  private generateFilename(template: ComplianceReportTemplate, format: ExportFormat): string {
    const timestamp = new Date().toISOString().split('T')[0];
    const ext = format.toLowerCase();
    return `${template.stateCode}_${template.reportType}_${timestamp}.${ext}`;
  }

  /**
   * Update report with generated file info
   */
  private async updateReportFiles(reportId: string, format: ExportFormat, fileInfo: GeneratedFileInfo): Promise<void> {
    await this.db.query(
      `UPDATE generated_compliance_reports
       SET generated_files = generated_files || $1::jsonb,
           file_size_bytes = COALESCE(file_size_bytes, 0) + $2,
           file_hash = $3,
           updated_at = NOW()
       WHERE id = $4`,
      [
        JSON.stringify({ [format]: fileInfo }),
        fileInfo.sizeBytes,
        fileInfo.hash,
        reportId
      ]
    );
  }

  /**
   * Get file path for a report export
   */
  async getFilePath(reportId: string, format: ExportFormat): Promise<string | null> {
    const result = await this.db.query(
      `SELECT generated_files FROM generated_compliance_reports WHERE id = $1`,
      [reportId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    const files = result.rows[0].generated_files;
    return files[format]?.path || null;
  }
}
